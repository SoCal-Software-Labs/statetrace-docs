"use strict";(self.webpackChunkstatetrace_docs=self.webpackChunkstatetrace_docs||[]).push([[896],{3905:function(e,t,n){n.d(t,{Zo:function(){return p},kt:function(){return m}});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var l=a.createContext({}),c=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},p=function(e){var t=c(e.components);return a.createElement(l.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},u=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,l=e.parentName,p=i(e,["components","mdxType","originalType","parentName"]),u=c(n),m=r,h=u["".concat(l,".").concat(m)]||u[m]||d[m]||o;return n?a.createElement(h,s(s({ref:t},p),{},{components:n})):a.createElement(h,s({ref:t},p))}));function m(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,s=new Array(o);s[0]=u;var i={};for(var l in t)hasOwnProperty.call(t,l)&&(i[l]=t[l]);i.originalType=e,i.mdxType="string"==typeof e?e:r,s[1]=i;for(var c=2;c<o;c++)s[c]=n[c];return a.createElement.apply(null,s)}return a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},5440:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return i},contentTitle:function(){return l},metadata:function(){return c},assets:function(){return p},toc:function(){return d},default:function(){return m}});var a=n(7462),r=n(3366),o=(n(7294),n(3905)),s=["components"],i={slug:"stream-postgres-elastic-search",title:"Stream Postgres Changes into Elasticsearch with Statetrace",description:"Stream Postgres Changes into Elasticsearch with Statetrace",authors:["kyle-hanson"],tags:["postgres","elixir","elasticsearch","elastic","search","statetrace"]},l=void 0,c={permalink:"/blog/stream-postgres-elastic-search",source:"@site/blog/2021-11-13-postgres-elasticsearch/index.md",title:"Stream Postgres Changes into Elasticsearch with Statetrace",description:"Stream Postgres Changes into Elasticsearch with Statetrace",date:"2021-11-13T00:00:00.000Z",formattedDate:"November 13, 2021",tags:[{label:"postgres",permalink:"/blog/tags/postgres"},{label:"elixir",permalink:"/blog/tags/elixir"},{label:"elasticsearch",permalink:"/blog/tags/elasticsearch"},{label:"elastic",permalink:"/blog/tags/elastic"},{label:"search",permalink:"/blog/tags/search"},{label:"statetrace",permalink:"/blog/tags/statetrace"}],readingTime:3.84,truncated:!0,authors:[{name:"Kyle Hanson",title:"CEO of Statetrace",url:"https://github.com/hansonkd",imageURL:"https://github.com/hansonkd.png",key:"kyle-hanson"}],prevItem:{title:"Build a Postgres Proxy in Elixir using Pattern Matching",permalink:"/blog/build-a-postgres-proxy"},nextItem:{title:"Build an Elixir Redis API that's 100x faster than HTTP",permalink:"/blog/redis-server"}},p={authorsImageUrls:[void 0]},d=[{value:"Configure the Databases in Docker-Compose",id:"configure-the-databases-in-docker-compose",children:[],level:2},{value:"Configure Statetrace",id:"configure-statetrace",children:[{value:"Middleware",id:"middleware",children:[],level:3},{value:"Request Builder",id:"request-builder",children:[],level:3}],level:2},{value:"Configure Statetrace in Docker-Compose",id:"configure-statetrace-in-docker-compose",children:[{value:"Get your License",id:"get-your-license",children:[],level:3},{value:"Make a secret",id:"make-a-secret",children:[],level:3},{value:"Add to YAML",id:"add-to-yaml",children:[],level:3},{value:"Conclusion",id:"conclusion",children:[],level:3}],level:2}],u={toc:d};function m(e){var t=e.components,n=(0,r.Z)(e,s);return(0,o.kt)("wrapper",(0,a.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("p",null,"Need to connect Postgres to Elasticsearch? Statetrace makes it easy to stream changes from your application database into the popular search engine."),(0,o.kt)("div",{style:{background:"url(/img/ipanema.jpg)",backgroundSize:"150px",width:"100%",height:"200px",marginTop:"30px",marginBottom:"30px"}}),(0,o.kt)("p",null,"Postgres is great for a lot of things, however sometimes your data access patterns require a search engine like ",(0,o.kt)("a",{parentName:"p",href:"https://www.elastic.co/"},"Elasticsearch"),". Unfortunately it can be tricky to keep ",(0,o.kt)("a",{parentName:"p",href:"https://www.postgresql.org/"},"Postgres")," synchronized with Elasticsearch when data changes. Luckily, Statetrace makes it easy."),(0,o.kt)("p",null,"In this article we will configure a local Postgres instance with Statetrace and pipe all changes into Elasticsearch for easy querying."),(0,o.kt)("h2",{id:"configure-the-databases-in-docker-compose"},"Configure the Databases in Docker-Compose"),(0,o.kt)("p",null,"I will use the standard docker-compose.yaml from the ",(0,o.kt)("a",{parentName:"p",href:"https://docs.statetrace.com/docs/intro"},"tutorial.")," with the addition of the elasticsearch container."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-yaml"},'version: \'3\'\n    \nservices:\n  postgres:\n    image: postgres\n    environment:\n      - POSTGRES_DB=postgres\n      - POSTGRES_USER=postgres\n      - POSTGRES_PASSWORD=postgres\n\n    command:\n      - "postgres"\n      - "-c"\n      - "wal_level=logical"\n      - "-c"\n      - "max_wal_senders=2"\n      - "-c"\n      - "max_replication_slots=2"\n    ports:\n      - "5432:5432"\n\n  es01:\n    image: docker.elastic.co/elasticsearch/elasticsearch:7.15.2\n    container_name: es01\n    environment:\n      - node.name=es01\n      - bootstrap.memory_lock=true\n      - "ES_JAVA_OPTS=-Xms512m -Xmx512m"\n    ulimits:\n      memlock:\n        soft: -1\n        hard: -1\n    volumes:\n      - data01:/usr/share/elasticsearch/data\n    ports:\n      - 9200:9200\n    networks:\n      - elastic\n  \n  # The buffer database\n  statetrace_db:\n    image: postgres\n    environment:\n      - POSTGRES_DB=postgres\n      - POSTGRES_USER=postgres\n      - POSTGRES_PASSWORD=postgres\n\n    command:\n      - "postgres"\n      - "-p"\n      - "5433"\n    ports:\n      - "5433:5433"\n')),(0,o.kt)("h2",{id:"configure-statetrace"},"Configure Statetrace"),(0,o.kt)("p",null,"We will use the following as our configuration for statetrace. "),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-yaml",metastring:'title="STATETRACE_INBOUND_CONFIG"',title:'"STATETRACE_INBOUND_CONFIG"'},'inbounds:\n  - name: Postgres DB\n    database_type: postgres\n    username: postgres\n    password: postgres\n    database: postgres\n    host: localhost\n    publication: "statetrace"\n    slot: "statetrace"\n    port: 5432\n    log_new_attributes: true\n    outbounds:\n        - name: Webhook\n          handler: webhook\n          target_url: "http://es01:9200/logs-statetrace_dump/_bulk"\n          middleware: |\n            fn \n              %{relation_name: tn} when tn in ["my_special_table"] -> :ok\n              _ -> :skip\n            end\n          request_builder: |\n            fn rows ->\n              payload = \n                rows\n                |> Enum.flat_map(fn row -> \n                    [\n                        Jason.encode_to_iodata!(%{"create" => %{}}),\n                        "\\n",\n                        Jason.encode_to_iodata!(Map.merge(%{"@timestamp" => row["row_timestamp"]}, row)),\n                        "\\n"\n                    ]\n                end)\n              %WebhookRequest{method: "POST", headers: [], payload: payload}\n            end\n')),(0,o.kt)("h3",{id:"middleware"},"Middleware"),(0,o.kt)("p",null,"An outbound middleware runs on every row and tells whether or not to include it in the outbound request. Elixir's pattern matching syntax makes it a breeze to match the tables we want to send to Elasticsearch."),(0,o.kt)("p",null,"In this example, we will only put rows from ",(0,o.kt)("inlineCode",{parentName:"p"},"my_special_table")," into the index."),(0,o.kt)("h3",{id:"request-builder"},"Request Builder"),(0,o.kt)("p",null,"In our webhook request, we return a closure that builds our WebhookRequest. The WebhookRequest allows you to set the method, headers and payload of your HTTP request as well as control what fields will be included in the payload. If you want to grab an environment variable, do it outside of the closure."),(0,o.kt)("p",null,"In Elasticsearch, bulk data is sent as newline-delimited JSON so we will have to format our paylaod accordingly."),(0,o.kt)("h2",{id:"configure-statetrace-in-docker-compose"},"Configure Statetrace in Docker-Compose"),(0,o.kt)("p",null,"Now we will add Statetrace to our Docker-compose settings"),(0,o.kt)("h3",{id:"get-your-license"},"Get your License"),(0,o.kt)("p",null,"Go to ",(0,o.kt)("a",{parentName:"p",href:"https://www.statetrace.com/statetrace-core"},"https://www.statetrace.com/statetrace-core")," to get your free ",(0,o.kt)("inlineCode",{parentName:"p"},"STATETRACE_LICENSE")," key. No email or sign-up required."),(0,o.kt)("h3",{id:"make-a-secret"},"Make a secret"),(0,o.kt)("p",null,"Run the following command to generate a STATETRACE_SECRET_KEY "),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-bash"},"head -c 500 /dev/urandom | tr -dc 'a-zA-Z0-9' | fold -w 32 | head -n 1\n")),(0,o.kt)("h3",{id:"add-to-yaml"},"Add to YAML"),(0,o.kt)("p",null,"Taking our Statetrace License, our STATETRACE_INBOUND_CONFIG above and tie it all together with the rest of our docker compose file."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-yaml",metastring:'title="docker-compose.yaml"',title:'"docker-compose.yaml"'},'version: \'3\'\n    \nservices:\n  postgres:\n    image: postgres\n    environment:\n      - POSTGRES_DB=postgres\n      - POSTGRES_USER=postgres\n      - POSTGRES_PASSWORD=postgres\n\n    command:\n      - "postgres"\n      - "-c"\n      - "wal_level=logical"\n      - "-c"\n      - "max_wal_senders=2"\n      - "-c"\n      - "max_replication_slots=2"\n    ports:\n      - "5432:5432"\n\n  es01:\n    image: docker.elastic.co/elasticsearch/elasticsearch:7.15.2\n    container_name: es01\n    environment:\n      - node.name=es01\n      - bootstrap.memory_lock=true\n      - "ES_JAVA_OPTS=-Xms512m -Xmx512m"\n    ulimits:\n      memlock:\n        soft: -1\n        hard: -1\n    volumes:\n      - data01:/usr/share/elasticsearch/data\n    ports:\n      - 9200:9200\n    networks:\n      - elastic\n  \n  # The buffer database\n  statetrace_db:\n    image: postgres\n    environment:\n      - POSTGRES_DB=postgres\n      - POSTGRES_USER=postgres\n      - POSTGRES_PASSWORD=postgres\n\n    command:\n      - "postgres"\n      - "-p"\n      - "5433"\n    ports:\n      - "5433:5433"\n\n\n  statetrace:\n    image: statetraceofficial/statetrace-beta\n    environment:\n      STATETRACE_DATABASE_URL: postgres://postgres:postgres@statetrace_db:5433/postgres\n      STATETRACE_SECRET_KEY_BASE: "123456789123456789123456789123456789123456789123456789123456789123456789"\n      STATETRACE_LICENSE: "<statetrace_license>"\n      STATETRACE_INBOUND_CONFIG: |\n          inbounds:\n            - name: Postgres DB\n              database_type: postgres\n              username: postgres\n              password: postgres\n              database: postgres\n              host: localhost\n              publication: "statetrace"\n              slot: "statetrace"\n              port: 5432\n              log_new_attributes: true\n              outbounds:\n                  - name: Webhook\n                    handler: webhook\n                    target_url: "http://es01:9200/logs-statetrace_dump/_bulk"\n                    middleware: |\n                      fn \n                        %{relation_name: tn} when tn in ["my_special_table"] -> :ok\n                        _ -> :skip\n                      end\n                    request_builder: |\n                        fn rows ->\n                          payload = \n                            rows\n                            |> Enum.flat_map(fn row -> \n                                [\n                                    Jason.encode_to_iodata!(%{"create" => %{}}),\n                                    "\\n",\n                                    Jason.encode_to_iodata!(Map.merge(%{"@timestamp" => row.row_timestamp}, row)),\n                                    "\\n"\n                                ]\n                            end)\n                          %WebhookRequest{method: "POST", headers: [{"content-type", "application/json"}], payload: payload}\n                        end\n    depends_on:\n      - statetrace_db\n      - postgres\n      - es01\n')),(0,o.kt)("p",null,"Now all changes happening in the postgres database that match the middleware will be streamed into Elasticsearch under the ",(0,o.kt)("inlineCode",{parentName:"p"},"logs-statetrace_dump")," index."),(0,o.kt)("h3",{id:"conclusion"},"Conclusion"),(0,o.kt)("p",null,"Keeping Postgres synchronized with Elasticsearch doesn't need to be hard. We have shown that we can configure the standard webhooks found in Statetrace and use them to push data into the search engine without a lot of configuration."),(0,o.kt)("p",null,"You can expand on this method to customize the data that you choose to index."))}m.isMDXComponent=!0}}]);